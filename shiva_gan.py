# -*- coding: utf-8 -*-
"""Shiva_GAN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s8eP8v1qSjZAp7DSK_9zKLEj4JPeSDw4
"""

# Commented out IPython magic to ensure Python compatibility.
import torch
import torch.optim as opt
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F


import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

size = 32

transform=torchvision.transforms.Compose(
        [torchvision.transforms.Resize(32), torchvision.transforms.ToTensor()]
    )
trainData = torchvision.datasets.MNIST('./data/', download=True, transform=transform, train=True)

trainLoader = torch.utils.data.DataLoader(trainData, shuffle=True, batch_size=size)

dataIter = iter(trainLoader)

imgs, labels = dataIter.next()

imgs.shape

def imshow(imgs):
    imgs = torchvision.utils.make_grid(imgs)
    npimgs = imgs.numpy()
    plt.figure(figsize=(8,8))
    plt.imshow(np.transpose(npimgs, (1,2,0)), cmap='Greys_r')
    plt.xticks([])
    plt.yticks([])
    plt.show()

Z_dim = 100
H_dim = 128
X_dim = imgs.view(imgs.size(0), -1).size(1)

print(Z_dim, H_dim, X_dim)

device = 'cuda'

f_map = 32 
n_out = 1

def weights_init(m):
    classname = m.__class__.__name__
    if classname.find('Conv') != -1:
        nn.init.normal_(m.weight.data, 0.0, 0.02)
    elif classname.find('BatchNorm') != -1:
        nn.init.normal_(m.weight.data, 1.0, 0.02)
        nn.init.constant_(m.bias.data, 0)

class Generator(nn.Module):
    def __init__(self):
        super(Generator, self).__init__()
        self.main = nn.Sequential(
            nn.ConvTranspose2d(Z_dim, f_map * 8, 4, 1, 0, bias=False),
            nn.BatchNorm2d(f_map * 8),
            nn.ReLU(True),
            
            nn.ConvTranspose2d(f_map * 8, f_map * 4, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f_map * 4),
            nn.ReLU(True),
            
            nn.ConvTranspose2d(f_map * 4, f_map * 2, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f_map * 2),
            nn.ReLU(True),
            
            nn.ConvTranspose2d(f_map * 2, n_out, 4, 2, 1, bias=False),
            nn.Tanh()
        )

    def forward(self, input):
        return self.main(input)

class Discriminator(nn.Module):
    def __init__(self):
        super(Discriminator, self).__init__()
        self.main = nn.Sequential(
            nn.Conv2d(n_out, f_map, 4, 2, 1, bias=False),
            nn.LeakyReLU(0.2, inplace=True),

            nn.Conv2d(f_map, f_map * 2, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f_map * 2),
            nn.LeakyReLU(0.2, inplace=True),

            nn.Conv2d(f_map * 2, f_map * 4, 4, 2, 1, bias=False),
            nn.BatchNorm2d(f_map * 4),
            nn.LeakyReLU(0.2, inplace=True),

            nn.Conv2d(f_map * 4, n_out, 4, 2, 1, bias=False),
            nn.Flatten(),
            nn.Linear(4, 1),
            nn.Sigmoid()
        )

    def forward(self, input):
        return self.main(input)

D = Discriminator().to(device)
D.apply(weights_init)

G = Generator().to(device)
G.apply(weights_init)

lr = 1e-3

g_opt = opt.Adam(G.parameters(), lr=lr)
d_opt = opt.Adam(D.parameters(), lr=lr)

for epoch in range(15):
    G_loss_run = 0.0
    D_loss_run = 0.0
    for i, data in enumerate(trainLoader):
        X, _ = data
        X = X.to(device)
        size = X.size(0)
        
        one_labels = torch.ones(size, 1).to(device)
        zero_labels = torch.zeros(size, 1).to(device)
        
        z = torch.randn(size, Z_dim, 1, 1).to(device)

        D_real = D(X)
        D_fake = D(G(z))
        
        D_real_loss = F.binary_cross_entropy(D_real, one_labels)
        D_fake_loss = F.binary_cross_entropy(D_fake, zero_labels)
        D_loss = D_real_loss + D_fake_loss
        
        d_opt.zero_grad()
        D_loss.backward()
        d_opt.step()
        
        z = torch.randn(size, Z_dim, 1, 1).to(device)
        D_fake = D(G(z))
        G_loss = F.binary_cross_entropy(D_fake, one_labels)
        
        g_opt.zero_grad()
        G_loss.backward()
        g_opt.step()
        
        G_loss_run += G_loss.item()
        D_loss_run += D_loss.item()
        
    print('Epoch:{},   G_loss:{},    D_loss:{}'.format(epoch, G_loss_run/(i+1), D_loss_run/(i+1)))
    
    samples = G(z).detach()
    samples = samples.view(samples.size(0), 1, 32, 32).cpu()
    imshow(samples)

z_te = torch.randn(32, 100, 1, 1).to(device)

